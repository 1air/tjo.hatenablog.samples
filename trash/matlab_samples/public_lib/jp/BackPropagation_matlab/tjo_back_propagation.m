function out=tjo_back_propagation(xvec,loop)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% バックプロパゲーション・ニューラルネットワーク by Takashi J. OZAKI %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 非常に単純なバックプロパゲーション・ニューラルネットワーク(BP)の実装です。
% 簡単のために3層（入力層・中間層1つ・出力層）構造にしてあります。
% そのため非線形分離そのものは可能ですが、XORには対応していません。
% （XORに対応させるには中間層がもう1つ必要です）

% 基本的に、BPはあくまでも単なるパーセプトロンの延長です。
% パーセプトロンは入力層・出力層の2層だけで単純な線形分離を行いますが、
% 間に中間層を挟んでいくことで分岐を増やし、非線形分離に対応できるように
% しています。「バックプロパゲーション」（逆伝播）の名前の通り、
% 出力信号と教師信号との差から中間層ならびに入力層の学習を行う点が
% 最大の特徴です。

% 数学的な利便性の都合上、分離関数をパーセプトロンの閾値関数(0 or 1)ではなく、
% シグモイド関数としています。このため、多少分離性能にムラがあったり、
% 学習の収束が悪かったりします。SVMに比べると綺麗に非線形分離できないことが
% 多々あるので注意が必要です。

% 実装時には入力データとしてxy座標に加えてバイアス項（ここではただの1）を
% 付け足す必要があり、入力層〜中間層の受け渡しデータにも同じバイアス項が
% 必要になります。

%%
%%%%%%%%%%%%%%%%%%%
% 教師信号のセット %
%%%%%%%%%%%%%%%%%%%
% 他のスクリプトに同じく、1だけのマトリクスを作り出すones関数と、
% 0-1の乱数のマトリクスを作り出すrand関数と、rand()に乗じるパラメータcとの
% 組み合わせで適当に作っています。

c=8;

% 第1・2・4象限がx1グループ
x1_list=[[(ones(1,10)+c*rand(1,10));(ones(1,10)+c*rand(1,10))] ...
    [(-1*ones(1,10)-c*rand(1,10));(ones(1,10)+c*rand(1,10))] ...
    [(ones(1,10)+c*rand(1,10));(-1*ones(1,10)-c*rand(1,10))]];
% 第3象限がx2グループ
x2_list=[-1*ones(1,15)-c*rand(1,15);-1*ones(1,15)-c*rand(1,15)];

c1=size(x1_list,2);
c2=size(x2_list,2);

% BPでは正解ラベル信号は0 or 1で与えます。
y_list=[ones(c1,1);zeros(c2,1)];

clength=c1+c2;

% BPではバイアス項（ただの1）を付け足す必要があるため、3行目に1が全ての列に
% 対して付け足してあります。
x_list=[[x1_list x2_list];ones(1,clength)];

%%
%%%%%%%%%%%%%%%%%%%%%
% 各種初期パラメータ %
%%%%%%%%%%%%%%%%%%%%%
k=1.5; % 学習係数

% 重みベクトル
wvec=[rand(2,2);ones(1,2)]; % 第1段階用
hvec=[rand(2,1);1]; % 第2段階用 / ここでは2段階しか想定してない


%%
%%%%%%%%%%%%%
% 学習パート %
%%%%%%%%%%%%%
% 別の関数にしてあります。
% 4つの関数から構成されているので、それぞれのコメントを参照のこと。
[wvec,hvec]=tjo_bp_train(wvec,hvec,x_list,y_list,clength,k,loop);

%%
%%%%%%%%%%%%%%%
% テストパート %
%%%%%%%%%%%%%%%

% 入力ベクトルにバイアス項1を3列目の位置に追加。
xvec0=[xvec;1];
% 入力ベクトルと2つの重みベクトルに基づいて出力値を算出。
out=tjo_bp_predict(xvec0,wvec,hvec);
% シグモイド関数なので、0.5を超えたか否かで判別する。
if(out>0.5)
    fprintf(1,'Group 1\n\n');
else
    fprintf(1,'Group 2\n\n');
end;
%%
%%%%%%%%%%%%%%%
% 可視化パート %
%%%%%%%%%%%%%%%

figure;

for i=1:c1
    scatter(x_list(1,i),x_list(2,i),100,'black');hold on;
end;

for i=c1+1:c1+c2
    scatter(x_list(1,i),x_list(2,i),100,'black','+');hold on;
end;

if(out > 0.5)
    scatter(xvec(1),xvec(2),200,'red');hold on;
elseif(out < 0.5)
    scatter(xvec(1),xvec(2),200,'red','+');hold on;
else
    scatter(xvec(1),xvec(2),200,'blue');hold on;
end;

%%
[xx,yy]=meshgrid(-10:0.1:10,-10:0.1:10);
cxx=size(xx,2);
zz=zeros(cxx,cxx);
for p=1:cxx
    for q=1:cxx
        zz(p,q)=tjo_bp_predict([xx(p,q);yy(p,q);1],wvec,hvec);
    end;
end;

contour(xx,yy,zz,50);hold on;

xlim([-10 10]);
ylim([-10 10]);
end